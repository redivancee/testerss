local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui")

local player = Players.LocalPlayer

-- MASTER TOGGLE STATE
local masterEnabled = false

-- DISABLE ORIGINAL GUN MODULE TO PREVENT DOUBLE BULLETS
local function removeGunController(obj)
    if obj.Name == "GunController" then
        if obj:IsA("Script") or obj:IsA("ModuleScript") then
            pcall(function() obj.Enabled = false end)
        end
        pcall(function() obj:Destroy() end)
    end
end

-- Remove existing ones
for _, obj in ipairs(workspace:GetDescendants()) do
    removeGunController(obj)
end

-- Remove any new ones instantly
workspace.DescendantAdded:Connect(removeGunController)

local mouse = player:GetMouse()
local camera = workspace.CurrentCamera

-- Modules (these must exist in the game)
local CharacterRayOrigin = require(ReplicatedStorage.Modules.CharacterRayOrigin)
local BulletRenderer = require(ReplicatedStorage.Modules.BulletRenderer)
local WeaponRaycast = require(ReplicatedStorage.Modules.WeaponRaycast)
local CollisionGroups = require(ReplicatedStorage.Modules.CollisionGroups)
local Maid = require(ReplicatedStorage.Modules.Util.Maid)
local Tags = require(ReplicatedStorage.Modules.Tags)

local character = player.Character or player.CharacterAdded:Wait()
local shootRemote = ReplicatedStorage.Remotes.ShootGun
local maid = Maid.new()
local lastShot = nil

-- Target System
local selectedTarget = nil

-- ESP Storage
local skeletons = {}

-- Simple Skeleton ESP Functions
local function createSkeleton(character)
    local skeleton = {}
    skeleton.lines = {}
    skeleton.character = character
    skeleton.player = Players:GetPlayerFromCharacter(character)
    
    -- Only essential connections for better performance
    local connections = {
        {"Head", "UpperTorso"},
        {"UpperTorso", "LowerTorso"},
        {"UpperTorso", "LeftUpperArm"},
        {"UpperTorso", "RightUpperArm"},
        {"LowerTorso", "LeftUpperLeg"},
        {"LowerTorso", "RightUpperLeg"}
    }
    
    for _, connection in pairs(connections) do
        local line = Drawing.new("Line")
        line.Color = Color3.fromRGB(255, 0, 0)
        line.Thickness = 2
        line.Visible = false
        skeleton.lines[#skeleton.lines + 1] = {line = line, parts = connection}
    end
    
    return skeleton
end

local function updateSkeleton(skeleton)
    if not masterEnabled or not skeleton.character or not skeleton.character.Parent then
        for _, data in pairs(skeleton.lines) do
            data.line.Visible = false
        end
        return
    end
    
    local character = skeleton.character
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    
    if not humanoidRootPart then
        for _, data in pairs(skeleton.lines) do
            data.line.Visible = false
        end
        return
    end
    
    -- Hide skeleton if too far
    local distance = (humanoidRootPart.Position - camera.CFrame.Position).Magnitude
    if distance > 500 then
        for _, data in pairs(skeleton.lines) do
            data.line.Visible = false
        end
        return
    end
    
    for _, data in pairs(skeleton.lines) do
        local part1 = character:FindFirstChild(data.parts[1])
        local part2 = character:FindFirstChild(data.parts[2])
        
        if part1 and part2 then
            local pos1, onScreen1 = camera:WorldToViewportPoint(part1.Position)
            local pos2, onScreen2 = camera:WorldToViewportPoint(part2.Position)
            
            -- Only show if both points are reasonably on screen
            if onScreen1 and onScreen2 and pos1.Z > 0 and pos2.Z > 0 then
                data.line.From = Vector2.new(pos1.X, pos1.Y)
                data.line.To = Vector2.new(pos2.X, pos2.Y)
                data.line.Visible = true
            else
                data.line.Visible = false
            end
        else
            data.line.Visible = false
        end
    end
end

local function removeSkeleton(skeleton)
    if skeleton then
        for _, data in pairs(skeleton.lines) do
            data.line:Remove()
        end
    end
end

-- Get nearest player to mouse click
local function getNearestPlayerToMouse()
    local mousePos = UserInputService:GetMouseLocation()
    local closestPlayer = nil
    local closestDistance = math.huge

    for _, target in pairs(Players:GetPlayers()) do
        if target ~= player and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then
            local screenPos, onScreen = camera:WorldToViewportPoint(target.Character.HumanoidRootPart.Position)
            
            if onScreen then
                local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
                if distance < closestDistance then
                    closestPlayer = target
                    closestDistance = distance
                end
            end
        end
    end

    return closestPlayer
end

-- Modified shoot function
local function silentShoot(tool, targetPos)
    if not masterEnabled or not tool or not tool.Enabled then return end
    if lastShot and tool:GetAttribute("Cooldown") and tick() - lastShot < tool:GetAttribute("Cooldown") then return end

    local muzzle = tool:FindFirstChild("Muzzle", true)
    if not muzzle then return end

    lastShot = tick()

    local finalTarget = targetPos
    if selectedTarget and selectedTarget.Character and selectedTarget.Character:FindFirstChild("Head") then
        finalTarget = selectedTarget.Character.Head.Position
    end
    
    if not finalTarget then
        finalTarget = mouse.Hit and mouse.Hit.Position or (camera.CFrame.Position + camera.CFrame.LookVector * 2000)
    end

    local screenRay = WeaponRaycast(camera.CFrame.Position, finalTarget, nil, CollisionGroups.SCREEN_RAYCAST)
    local characterRay = CharacterRayOrigin(character)

    if characterRay then
        local hitResult = WeaponRaycast(characterRay, screenRay and screenRay.Position or finalTarget)
        if not hitResult and screenRay then
            hitResult = screenRay
        end

        local fireSound = tool:FindFirstChild("Fire")
        if fireSound then pcall(function() fireSound:Play() end) end

        BulletRenderer(
            muzzle.WorldPosition,
            hitResult and hitResult.Position or finalTarget,
            tool:GetAttribute("BulletRenderer")
        )

        tool:Activate()

        shootRemote:FireServer(
            characterRay,
            finalTarget,
            hitResult and hitResult.Instance or nil,
            hitResult and hitResult.Position or nil
        )
    end
end

local function addSkeletonForPlayer(targetPlayer)
    if not masterEnabled then return end
    if targetPlayer.Character and not skeletons[targetPlayer] then
        local skeleton = createSkeleton(targetPlayer.Character)
        skeletons[targetPlayer] = skeleton
    end
end

local function removeSkeletonForPlayer(targetPlayer)
    if skeletons[targetPlayer] then
        removeSkeleton(skeletons[targetPlayer])
        skeletons[targetPlayer] = nil
    end
end

-- Tool handler
local function handleTool(tool)
    if not masterEnabled then return end
    if tool:IsA("Tool") and CollectionService:HasTag(tool, Tags.GUN_TOOL) then
        maid:DoCleaning()

        maid:GiveTask(tool.AncestryChanged:Connect(function()
            if not tool:IsDescendantOf(character) then
                maid:DoCleaning()
            end
        end))

        -- Mouse input with target selection
        maid:GiveTask(UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if gameProcessed then return end
            if input.UserInputType == Enum.UserInputType.MouseButton1 or input.KeyCode == Enum.KeyCode.ButtonR2 then
                -- Select nearest target on click
                selectedTarget = getNearestPlayerToMouse()
                silentShoot(tool)
            end
        end))

        -- Touch input
        maid:GiveTask(UserInputService.TouchTapInWorld:Connect(function(position, gameProcessed)
            if gameProcessed then return end
            selectedTarget = getNearestPlayerToMouse()
            local worldPos = WeaponRaycast.convertScreenPointToVector3(position, 2000)
            silentShoot(tool, worldPos)
        end))
    end
end

local function onCharacterAdded(newCharacter, targetPlayer)
    if masterEnabled then
        addSkeletonForPlayer(targetPlayer)
    end
    newCharacter.AncestryChanged:Connect(function(_, parent)
        if not parent then
            removeSkeletonForPlayer(targetPlayer)
        end
    end)
end

-- Player connections
Players.PlayerAdded:Connect(function(targetPlayer)
    targetPlayer.CharacterAdded:Connect(function(newCharacter)
        onCharacterAdded(newCharacter, targetPlayer)
    end)
end)

Players.PlayerRemoving:Connect(function(targetPlayer)
    removeSkeletonForPlayer(targetPlayer)
    if selectedTarget == targetPlayer then
        selectedTarget = nil
    end
end)

-- Handle existing players
for _, pl in pairs(Players:GetPlayers()) do
    if pl ~= player then
        if pl.Character then
            if masterEnabled then
                addSkeletonForPlayer(pl)
            end
        end
        pl.CharacterAdded:Connect(function(newCharacter)
            onCharacterAdded(newCharacter, pl)
        end)
    end
end

-- Handle character respawning
character.ChildAdded:Connect(function(child)
    if masterEnabled then
        handleTool(child)
    end
end)

for _, child in pairs(character:GetChildren()) do
    if masterEnabled then
        handleTool(child)
    end
end

player.CharacterAdded:Connect(function(newChar)
    character = newChar
    maid:DoCleaning()

    character.ChildAdded:Connect(function(child)
        if masterEnabled then
            handleTool(child)
        end
    end)
    for _, child in pairs(character:GetChildren()) do
        if masterEnabled then
            handleTool(child)
        end
    end
end)

-- SUPER SIMPLE GUI
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "CheatGUI"
screenGui.ResetOnSpawn = false
screenGui.Parent = player:WaitForChild("PlayerGui")

local toggle = Instance.new("TextButton")
toggle.Size = UDim2.new(0, 120, 0, 40)
toggle.Position = UDim2.new(0, 10, 0, 10)
toggle.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
toggle.Text = "OFF"
toggle.TextColor3 = Color3.new(1, 1, 1)
toggle.TextSize = 20
toggle.Font = Enum.Font.SourceSansBold
toggle.Parent = screenGui

-- Master Toggle Function
local function toggleMaster()
    masterEnabled = not masterEnabled
    
    if masterEnabled then
        toggle.Text = "ON"
        toggle.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
        
        -- Add skeletons for all players
        for _, pl in pairs(Players:GetPlayers()) do
            if pl ~= player and pl.Character then
                addSkeletonForPlayer(pl)
            end
        end
        
        -- Handle tools
        for _, child in pairs(character:GetChildren()) do
            handleTool(child)
        end
    else
        toggle.Text = "OFF"
        toggle.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
        
        -- Remove all skeletons
        for targetPlayer, skeleton in pairs(skeletons) do
            removeSkeleton(skeleton)
        end
        skeletons = {}
        
        -- Clear selected target
        selectedTarget = nil
        
        -- Clean up tools
        maid:DoCleaning()
    end
end

toggle.MouseButton1Click:Connect(toggleMaster)

-- Simple update loop with frame limiting
local lastUpdateTime = 0
RunService.Heartbeat:Connect(function()
    if masterEnabled then
        local currentTime = tick()
        if currentTime - lastUpdateTime >= 0.05 then -- Update every 0.05 seconds (20 FPS)
            for _, skeleton in pairs(skeletons) do
                if skeleton and skeleton.character and skeleton.character.Parent then
                    updateSkeleton(skeleton)
                end
            end
            lastUpdateTime = currentTime
        end
    end
end)

-- GUI Dragging
local dragging = false
local dragInput, dragStart, startPos

toggle.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        startPos = toggle.Position
        
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

toggle.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement then
        dragInput = input
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if dragging and input == dragInput then
        local delta = input.Position - dragStart
        toggle.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
end)
